---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: Src/Graph/Tree/Rerooting.hpp
    title: "\u6728DP/\u5168\u65B9\u4F4D\u6728DP"
  - icon: ':heavy_check_mark:'
    path: Src/Template/TypeAlias.hpp
    title: "\u6A19\u6E96\u30C7\u30FC\u30BF\u578B\u306E\u30A8\u30A4\u30EA\u30A2\u30B9"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/problems/1595
    links:
    - https://onlinejudge.u-aizu.ac.jp/problems/1595
  bundledCode: "#line 1 \"Test/AOJ/1595.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/1595\"\
    \n\n#line 2 \"Src/Graph/Tree/Rerooting.hpp\"\n\n#line 2 \"Src/Template/TypeAlias.hpp\"\
    \n\n#include <cstdint>\n#include <cstddef>\n\nnamespace zawa {\n\nusing i16 =\
    \ std::int16_t;\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing i128\
    \ = __int128_t;\n\nusing u8 = std::uint8_t;\nusing u16 = std::uint16_t;\nusing\
    \ u32 = std::uint32_t;\nusing u64 = std::uint64_t;\n\nusing usize = std::size_t;\n\
    \n} // namespace zawa\n#line 4 \"Src/Graph/Tree/Rerooting.hpp\"\n\n#include <vector>\n\
    #include <cassert>\n#include <concepts>\n#include <limits>\n\nnamespace zawa {\n\
    \nnamespace concepts {\n\ntemplate <class T>\nconcept TreeDP = requires {\n  \
    \  typename T::Tree;\n    typename T::Cluster;\n    typename T::Edge;\n    typename\
    \ T::Vertex;\n    { T::Convert(std::declval<typename T::Vertex>()) } -> std::same_as<typename\
    \ T::Tree>;\n    { T::AddEdge(std::declval<typename T::Tree>(), std::declval<typename\
    \ T::Edge>()) } -> std::same_as<typename T::Cluster>;\n    { T::Merge(std::declval<typename\
    \ T::Cluster>(), std::declval<typename T::Cluster>()) } -> std::same_as<typename\
    \ T::Cluster>;\n    { T::AddVertex(std::declval<typename T::Cluster>(), std::declval<typename\
    \ T::Vertex>()) } -> std::same_as<typename T::Tree>;\n};\n\n}\n\ntemplate <concepts::TreeDP\
    \ T>\nusing TreeDPGraph = std::vector<std::vector<std::pair<usize, typename T::Edge>>>;\n\
    \ntemplate <concepts::TreeDP T>\nstd::vector<typename T::Tree> TreeDP(const TreeDPGraph<T>&\
    \ g, const std::vector<typename T::Vertex>& vs, usize root) {\n    using Tree\
    \ = typename T::Tree;\n    using Cluster = typename T::Cluster;\n    // using\
    \ Edge = typename T::Edge;\n    // using Vertex = typename T::Vertex;\n    assert(g.size()\
    \ == vs.size());\n    const usize n = g.size();\n    std::vector<Tree> res(n);\n\
    \    auto rec = [&](auto rec, usize v, usize p) -> Tree {\n        if (ssize(g[v])\
    \ == 1 and g[v][0].first == p)\n            return res[v] = T::Convert(vs[v]);\n\
    \        usize idx = g[v][0].first == p ? 1 : 0;\n        assert(idx < g[v].size());\n\
    \        Cluster cluster = T::AddEdge(rec(rec, g[v][idx].first, v), g[v][idx].second);\n\
    \        idx++;\n        for ( ; idx < g[v].size() ; idx++) {\n            Cluster\
    \ cur = T::AddEdge(rec(rec, g[v][idx].first, v), g[v][idx].second);\n        \
    \    cluster = T::Merge(cluster, cur);\n        }\n        return res[v] = T::AddVertex(cluster,\
    \ vs[v]);\n    };\n    rec(rec, root, g.size());\n    return res;\n}\n\ntemplate\
    \ <concepts::TreeDP T>\nstd::vector<typename T::Tree> Rerooting(const TreeDPGraph<T>&\
    \ g, const std::vector<typename T::Vertex>& vs) {\n    using Tree = typename T::Tree;\n\
    \    using Cluster = typename T::Cluster;\n    // using Edge = typename T::Edge;\n\
    \    // using Vertex = typename T::Vertex;\n    assert(g.size() == vs.size());\n\
    \    const usize n = g.size();\n    if (n <= 2) {\n        std::vector<Tree> res(n);\n\
    \        for (usize i = 0 ; i < n ; i++)\n            res[i] = TreeDP<T>(g, vs,\
    \ i)[i];\n        return res;\n    }\n    std::vector<Cluster> dp(n);\n    auto\
    \ rec1 = [&](auto rec, usize v, usize p) -> Tree {\n        if (ssize(g[v]) ==\
    \ 1 and g[v][0].first == p)\n            return T::Convert(vs[v]);\n        usize\
    \ idx = g[v][0].first == p ? 1 : 0;\n        assert(idx < g[v].size());\n    \
    \    dp[v] = T::AddEdge(rec(rec, g[v][idx].first, v), g[v][idx].second);\n   \
    \     idx++;\n        for ( ; idx < g[v].size() ; idx++)\n            if (g[v][idx].first\
    \ != p) {\n                Cluster cur = T::AddEdge(rec(rec, g[v][idx].first,\
    \ v), g[v][idx].second);\n                dp[v] = T::Merge(dp[v], cur);\n    \
    \        }\n        return T::AddVertex(dp[v], vs[v]);\n    };\n    usize root\
    \ = 0;\n    while (root < g.size() and g[root].size() <= 1)\n        root++;\n\
    \    assert(root < g.size());\n    std::vector<Tree> res(n);\n    res[root] =\
    \ rec1(rec1, root, g.size());\n    auto rec2 = [&](auto rec, usize v, usize p,\
    \ Cluster pv) -> void {\n        if (ssize(g[v]) == 1) {\n            assert(g[v][0].first\
    \ == p);\n            res[v] = T::AddVertex(pv, vs[v]);\n            return;\n\
    \        }\n        assert(ssize(g[v]) >= 2);\n        std::vector<Cluster> pref(g[v].size()),\
    \ suf(g[v].size());\n        pref[0] = g[v][0].first == p ? pv : T::AddEdge(dp[g[v][0].first],\
    \ g[v][0].second);\n        for (usize i = 1 ; i < g[v].size() ; i++) {\n    \
    \        Cluster cur = g[v][i].first == p ? pv : T::AddEdge(dp[g[v][i].first],\
    \ g[v][i].second);\n            pref[i] = T::Merge(pref[i - 1], cur);\n      \
    \  }\n        suf[g[v].size() - 1] = g[v].back().first == p ? pv : T::AddEdge(dp[g[v].back().first],\
    \ g[v].back().second);\n        for (usize i = g[v].size() - 1 ; i-- ; ) {\n \
    \           Cluster cur = g[v][i].first == p ? pv : T::AddEdge(dp[g[v][i].first],\
    \ g[v][i].second);\n            suf[i] = T::Merge(cur, suf[i + 1]);\n        }\n\
    \        res[v] = T::AddVertex(pref.back(), vs[v]);\n        for (usize i = 0\
    \ ; i < g[v].size() ; i++)\n            if (g[v][i].first != p) {\n          \
    \      Cluster pc = i == 0 ? suf[1] : (i + 1 == g[v].size() ? pref[i - 1] : T::Merge(pref[i\
    \ - 1], suf[i + 1]));\n                rec(rec, g[v][i].first, v, T::AddEdge(T::AddVertex(pc,\
    \ vs[v]), g[v][i].second));\n            }\n    };\n    rec2(rec2, root, g.size(),\
    \ Cluster{});\n    return res;\n}\n\n} // namespace zawa\n#line 4 \"Test/AOJ/1595.test.cpp\"\
    \n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing namespace\
    \ zawa;\nstruct DP {\n    using Tree = int;\n    using Cluster = int;\n    using\
    \ Edge = int;\n    using Vertex = int;\n    static Tree Convert(Vertex) {\n  \
    \      return 0;\n    }\n    static Cluster AddEdge(Tree t, Edge) {\n        return\
    \ t + 1;\n    }\n    static Cluster Merge(Cluster l, Cluster r) {\n        return\
    \ max(l, r);\n    }\n    static Tree AddVertex(Cluster c, Vertex) {\n        return\
    \ c;\n    }\n};\nusing G = TreeDPGraph<DP>;\n//#include <random>\nint main() {\n\
    \    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(0); \n    int N;\n\
    \    cin >> N;\n    G g(N);\n    for (int i = 1 ; i < N ; i++) {\n        int\
    \ u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back({v,\
    \ 0});\n        g[v].push_back({u, 0});\n    }\n    auto far = Rerooting<DP>(g,\
    \ vector<int>(N));\n    for (int i = 0 ; i < N ; i++)\n        cout << 2 * (N\
    \ - 1) - far[i] << '\\n';\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/1595\"\n\n#include\
    \ \"../../Src/Graph/Tree/Rerooting.hpp\"\n#include <iostream>\n#include <algorithm>\n\
    using namespace std;\nusing namespace zawa;\nstruct DP {\n    using Tree = int;\n\
    \    using Cluster = int;\n    using Edge = int;\n    using Vertex = int;\n  \
    \  static Tree Convert(Vertex) {\n        return 0;\n    }\n    static Cluster\
    \ AddEdge(Tree t, Edge) {\n        return t + 1;\n    }\n    static Cluster Merge(Cluster\
    \ l, Cluster r) {\n        return max(l, r);\n    }\n    static Tree AddVertex(Cluster\
    \ c, Vertex) {\n        return c;\n    }\n};\nusing G = TreeDPGraph<DP>;\n//#include\
    \ <random>\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(0);\
    \ \n    int N;\n    cin >> N;\n    G g(N);\n    for (int i = 1 ; i < N ; i++)\
    \ {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back({v,\
    \ 0});\n        g[v].push_back({u, 0});\n    }\n    auto far = Rerooting<DP>(g,\
    \ vector<int>(N));\n    for (int i = 0 ; i < N ; i++)\n        cout << 2 * (N\
    \ - 1) - far[i] << '\\n';\n}\n"
  dependsOn:
  - Src/Graph/Tree/Rerooting.hpp
  - Src/Template/TypeAlias.hpp
  isVerificationFile: true
  path: Test/AOJ/1595.test.cpp
  requiredBy: []
  timestamp: '2025-12-01 12:59:00+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: Test/AOJ/1595.test.cpp
layout: document
redirect_from:
- /verify/Test/AOJ/1595.test.cpp
- /verify/Test/AOJ/1595.test.cpp.html
title: Test/AOJ/1595.test.cpp
---
