---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: Src/Algebra/Group/AdditiveGroup.hpp
    title: "\u52A0\u6CD5\u7FA4"
  - icon: ':heavy_check_mark:'
    path: Src/Algebra/Group/GroupConcept.hpp
    title: Src/Algebra/Group/GroupConcept.hpp
  - icon: ':heavy_check_mark:'
    path: Src/Algebra/Monoid/MonoidConcept.hpp
    title: Src/Algebra/Monoid/MonoidConcept.hpp
  - icon: ':heavy_check_mark:'
    path: Src/Algebra/Semigroup/SemigroupConcept.hpp
    title: Src/Algebra/Semigroup/SemigroupConcept.hpp
  - icon: ':heavy_check_mark:'
    path: Src/DataStructure/FenwickTree/FenwickTree.hpp
    title: Fenwick Tree
  - icon: ':heavy_check_mark:'
    path: Src/Sequence/CompressedSequence.hpp
    title: "\u5EA7\u6A19\u5727\u7E2E"
  - icon: ':heavy_check_mark:'
    path: Src/Template/TypeAlias.hpp
    title: "\u6A19\u6E96\u30C7\u30FC\u30BF\u578B\u306E\u30A8\u30A4\u30EA\u30A2\u30B9"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A
    links:
    - https://contest.ucup.ac/contest/2551/problem/14140
    - https://contest.ucup.ac/submission/1507848
    - https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n          \
    \         ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  File \"/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/onlinejudge_verify/languages/cplusplus.py\"\
    , line 187, in bundle\n    bundler.update(path)\n    ~~~~~~~~~~~~~~^^^^^^\n  File\
    \ \"/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/onlinejudge_verify/languages/cplusplus_bundle.py\"\
    , line 401, in update\n    self.update(self._resolve(pathlib.Path(included), included_from=path))\n\
    \                ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \ File \"/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/onlinejudge_verify/languages/cplusplus_bundle.py\"\
    , line 260, in _resolve\n    raise BundleErrorAt(path, -1, \"no such header\"\
    )\nonlinejudge_verify.languages.cplusplus_bundle.BundleErrorAt: atcoder/modint.hpp:\
    \ line -1: no such header\n"
  code: "// #define PROBLEM \"https://contest.ucup.ac/contest/2551/problem/14140\"\
    \n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A\"\
    \n\n/*\n * The 4th Universal Cup. Stage 2: Grand Prix of Paris K. $k$ Operations\n\
    \ * https://contest.ucup.ac/submission/1507848\n */\n\n#include \"../../Src/Algebra/Group/AdditiveGroup.hpp\"\
    \n#include \"../../Src/DataStructure/FenwickTree/FenwickTree.hpp\"\n#include \"\
    ../../Src/Sequence/CompressedSequence.hpp\"\n#include \"atcoder/modint.hpp\"\n\
    #include <iostream>\n#include <vector>\n#include <algorithm>\nusing mint = atcoder::modint998244353;\n\
    using namespace zawa;\nusing namespace std;\nstruct MULT {\n    using Element\
    \ = mint;\n    static Element identity() {\n        return 1;\n    }\n    static\
    \ Element operation(Element l, Element r) {\n        return l * r;\n    }\n  \
    \  static Element inverse(Element v) {\n        return v.inv();\n    }\n};\nint\
    \ main() {\n#ifdef ONLINE_JUDGE\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(0);\n\
    \    int N, Q;\n    cin >> N >> Q;\n    vector<long long> A(N);\n    for (long\
    \ long& a : A)\n        cin >> a;\n    vector<int> L(Q), R(Q);\n    vector<long\
    \ long> K(Q);\n    for (int i = 0 ; i < Q ; i++) {\n        cin >> L[i] >> R[i]\
    \ >> K[i];\n        L[i]--;\n    }\n    CompressedSequence compA(A);\n    vector<vector<int>>\
    \ buc(compA.size());\n    for (int i = 0 ; i < N ; i++)\n        buc[compA.map(i)].push_back(i);\n\
    \    // detect a_i\n    // if first == 998.., all op\n    vector<long long> over\
    \ = [&]() {\n        vector<long long> ok(Q, 998244353), ng(Q, 0), mid(Q);\n \
    \       while (true) {\n            vector<int> app, idx;\n            for (int\
    \ i = 0 ; i < Q ; i++)\n                if (ok[i] - ng[i] > 1) {\n           \
    \         mid[i] = (ok[i] + ng[i]) / 2;\n                    app.push_back(mid[i]);\n\
    \                    idx.push_back(i);\n                }\n            if (idx.empty())\n\
    \                break;\n            CompressedSequence comp(app);\n         \
    \   vector<vector<int>> query(comp.size());\n            for (int i = 0 ; i <\
    \ ssize(app) ; i++)\n                query[comp.map(i)].push_back(idx[i]);\n \
    \           FenwickTree<AdditiveGroup<long long>> fen(N);\n            for (int\
    \ i = 0, j = 0 ; j < ssize(query) ; j++) {\n                while (i < ssize(buc)\
    \ and compA.inverse(i) <= comp.inverse(j)) {\n                    for (int k :\
    \ buc[i])\n                        fen.operation(k, A[k] - 1);\n             \
    \       i++;\n                }\n                for (int k : query[j]) {\n  \
    \                  long long pd = fen.product(L[k], R[k]);\n                 \
    \   if (pd >= K[k])\n                        ok[k] = mid[k];\n               \
    \     else\n                        ng[k] = mid[k];\n                }\n     \
    \       }\n        }\n        return ok;\n    }();\n    // detect hoge\n    vector<pair<int,\
    \ long long>> bimyou = [&]() {\n        vector<long long> app;\n        vector<int>\
    \ idx;\n        for (int i = 0 ; i < Q ; i++) {\n            if (1 < over[i] and\
    \ over[i] < 998244353) {\n                idx.push_back(i);\n                app.push_back(over[i]\
    \ - 1);\n            }\n        }\n        CompressedSequence comp(app);\n   \
    \     vector<vector<int>> query(comp.size());\n        for (int i = 0 ; i < ssize(app)\
    \ ; i++)\n            query[comp.map(i)].push_back(idx[i]);\n        FenwickTree<AdditiveGroup<long\
    \ long>> fen(N);\n        vector<long long> res(Q, -1);\n        vector<int> cnt(Q,\
    \ -1);\n        for (int i = 0, j = 0 ; j < ssize(query) ; j++) {\n          \
    \  while (i < ssize(buc) and compA.inverse(i) <= comp.inverse(j)) {\n        \
    \        for (int k : buc[i])\n                    fen.operation(k, A[k] - 1);\n\
    \                i++;\n            }\n            for (int k : query[j]) {\n \
    \               long long pd = fen.product(L[k], R[k]);\n                assert(pd\
    \ < K[k]);\n                cnt[k] = (K[k] - pd) / (over[k] - 1);\n          \
    \      res[k] = (K[k] - pd) % (over[k] - 1);\n            }\n        }\n     \
    \   vector<pair<int, long long>> tmp(Q);\n        for (int i = 0 ; i < Q ; i++)\n\
    \            tmp[i] = {cnt[i], res[i]};\n        return tmp;\n    }();\n    vector<mint>\
    \ ans = [&]() {\n        vector<mint> res(Q);\n        for (int i = 0 ; i < Q\
    \ ; i++)\n            if (over[i] == 998244353)\n                res[i] = 1;\n\
    \        vector<long long> app;\n        vector<int> idx;\n        for (int i\
    \ = 0 ; i < Q ; i++) {\n            if (1 < over[i] and over[i] < 998244353) {\n\
    \                idx.push_back(i);\n                app.push_back(over[i]);\n\
    \            }\n        }\n        CompressedSequence comp(app);\n        vector<vector<int>>\
    \ query(comp.size());\n        for (int i = 0 ; i < ssize(app) ; i++)\n      \
    \      query[comp.map(i)].push_back(idx[i]);\n        FenwickTree<MULT> fen(N);\n\
    \        for (int i = ssize(compA) - 1, j = ssize(comp) - 1 ; j >= 0 ; j--) {\n\
    \            while (i >= 0 and compA.inverse(i) >= comp.inverse(j)) {\n      \
    \          for (int k : buc[i]) {\n                    fen.assign(k, A[k]);\n\
    \                }\n                i--;\n            }\n            for (int\
    \ k : query[j]) {\n                mint pd = fen.product(L[k], R[k]);\n      \
    \          pd /= mint{over[k]}.pow(bimyou[k].first + 1);\n                pd *=\
    \ over[k] - bimyou[k].second;\n                res[k] = pd;\n            }\n \
    \       }\n        for (int i = 0 ; i < Q ; i++)\n            if (over[i] == 1)\n\
    \                res[i] = fen.product(L[i], R[i]);\n        return res;\n    }();\n\
    \    for (mint a : ans)\n        cout << a.val() << '\\n';\n#else\n    cout <<\
    \ \"Hello World\\n\";\n#endif\n}\n"
  dependsOn:
  - Src/Algebra/Group/AdditiveGroup.hpp
  - Src/DataStructure/FenwickTree/FenwickTree.hpp
  - Src/Template/TypeAlias.hpp
  - Src/Algebra/Group/GroupConcept.hpp
  - Src/Algebra/Monoid/MonoidConcept.hpp
  - Src/Algebra/Semigroup/SemigroupConcept.hpp
  - Src/Sequence/CompressedSequence.hpp
  isVerificationFile: true
  path: Test/UC/4-2-K.test.cpp
  requiredBy: []
  timestamp: '2025-10-14 12:56:31+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: Test/UC/4-2-K.test.cpp
layout: document
redirect_from:
- /verify/Test/UC/4-2-K.test.cpp
- /verify/Test/UC/4-2-K.test.cpp.html
title: Test/UC/4-2-K.test.cpp
---
