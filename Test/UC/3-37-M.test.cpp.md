---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: Src/GeometryR3/Plane.hpp
    title: Src/GeometryR3/Plane.hpp
  - icon: ':heavy_check_mark:'
    path: Src/GeometryR3/Point.hpp
    title: Src/GeometryR3/Point.hpp
  - icon: ':heavy_check_mark:'
    path: Src/Template/TypeAlias.hpp
    title: "\u6A19\u6E96\u30C7\u30FC\u30BF\u578B\u306E\u30A8\u30A4\u30EA\u30A2\u30B9"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A
    links:
    - https://contest.ucup.ac/contest/2025/problem/10748
    - https://contest.ucup.ac/submission/1067790
    - https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A
  bundledCode: "#line 1 \"Test/UC/3-37-M.test.cpp\"\n// #define PROBLEM \"https://contest.ucup.ac/contest/2025/problem/10748\"\
    \n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A\"\
    \n\n/*\n * The 3rd Universal Cup. Stage 37: Wuhan M. Flight Tracker\n * https://contest.ucup.ac/submission/1067790\n\
    \ */\n\n#line 2 \"Src/GeometryR3/Point.hpp\"\n\n#include <array>\n#include <cassert>\n\
    #include <cmath>\n#include <concepts>\n#include <iostream>\n#include <utility>\n\
    \n#line 2 \"Src/Template/TypeAlias.hpp\"\n\n#include <cstdint>\n#include <cstddef>\n\
    \nnamespace zawa {\n\nusing i16 = std::int16_t;\nusing i32 = std::int32_t;\nusing\
    \ i64 = std::int64_t;\nusing i128 = __int128_t;\n\nusing u8 = std::uint8_t;\n\
    using u16 = std::uint16_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\n\
    \nusing usize = std::size_t;\n\n} // namespace zawa\n#line 11 \"Src/GeometryR3/Point.hpp\"\
    \n\nnamespace zawa {\n\nnamespace geometryR3 {\n\ntemplate <std::floating_point\
    \ T>\nclass Point {\npublic:\n\n    Point() = default;\n\n    Point(T x, T y,\
    \ T z) : m_p{x, y, z} {}\n\n    explicit Point(const std::array<T, 3>& p) : m_p{p}\
    \ {}\n\n    explicit Point(std::array<T, 3>&& p) : m_p{std::move(p)} {}\n\n  \
    \  const T& x() const {\n        return m_p[0];\n    }\n\n    T& x() {\n     \
    \   return m_p[0];\n    }\n\n    const T& y() const {\n        return m_p[1];\n\
    \    }\n\n    T& y() {\n        return m_p[1];\n    }\n\n    const T& z() const\
    \ {\n        return m_p[2];\n    }\n\n    T& z() {\n        return m_p[2];\n \
    \   }\n\n    const T& operator[](usize i) const {\n        assert(i < 3);\n  \
    \      return m_p[i];\n    }\n\n    T& operator[](usize i) {\n        assert(i\
    \ < 3);\n        return m_p[i];\n    }\n\n    Point<T>& operator+=(const Point<T>&\
    \ p) {\n        m_p[0] += p[0];\n        m_p[1] += p[1];\n        m_p[2] += p[2];\n\
    \        return *this;\n    }\n\n    Point<T>& operator-=(const Point<T>& p) {\n\
    \        m_p[0] -= p[0];\n        m_p[1] -= p[1];\n        m_p[2] -= p[2];\n \
    \       return *this;\n    }\n\n    Point<T>& operator*=(T k) {\n        m_p[0]\
    \ *= k;\n        m_p[1] *= k;\n        m_p[2] *= k;\n        return *this;\n \
    \   }\n\n    Point<T>& operator/=(T k) {\n        m_p[0] /= k;\n        m_p[1]\
    \ /= k;\n        m_p[2] /= k;\n        return *this;\n    }\n\n    T normSquare()\
    \ const {\n        return m_p[0]*m_p[0] + m_p[1]*m_p[1] + m_p[2]*m_p[2];\n   \
    \ }\n\n    T norm() const {\n        return sqrtl(normSquare());\n    }\n\n  \
    \  Point<T> normalized() const {\n        return Point<T>{*this} /= norm();\n\
    \    }\n\n    // \u30ED\u30C9\u30EA\u30B2\u30B9\u306E\u56DE\u8EE2\u516C\u5F0F\
    \ https://manabitimes.jp/math/2649\n    Point<T> rotated(const Point<T>& axis,\
    \ T theta) const {\n        const T cosT = cosl(theta), sinT = sinl(theta);\n\
    \        const Point<T> cp{*this};\n        return cosT * cp + (1 - cosT) * DotProduct(axis,\
    \ cp) * axis + sinT * CrossProduct(axis, cp);\n    }\n\nprivate:\n\n    std::array<T,\
    \ 3> m_p{T{0}, T{0}, T{0}};\n\n};\n\ntemplate <std::floating_point T>\nPoint<T>\
    \ operator+(const Point<T>& lhs, const Point<T>& rhs) {\n    return Point<T>{lhs}\
    \ += rhs;\n}\n\ntemplate <std::floating_point T>\nPoint<T> operator-(const Point<T>&\
    \ lhs, const Point<T>& rhs) {\n    return Point<T>{lhs} -= rhs;\n}\n\ntemplate\
    \ <std::floating_point T>\nPoint<T> operator*(const T k, const Point<T>& p) {\n\
    \    return Point<T>{p} *= k;\n}\n\ntemplate <std::floating_point T>\nstd::ostream&\
    \ operator<<(std::ostream& os, const Point<T>& p) {\n    os << '(' << p[0] <<\
    \ ',' << p[1] << ',' << p[2] << ')';\n    return os;\n}\n\ntemplate <std::floating_point\
    \ T>\nstd::istream& operator>>(std::istream& is, Point<T>& p) {\n    is >> p[0]\
    \ >> p[1] >> p[2];\n    return is;\n}\n\ntemplate <std::floating_point T>\nT DistanceSquare(const\
    \ Point<T>& lhs, const Point<T>& rhs) {\n    return Point{lhs - rhs}.normSquare();\n\
    }\n\ntemplate <std::floating_point T>\nT Distance(const Point<T>& lhs, const Point<T>&\
    \ rhs) {\n    return sqrtl(DistanceSquare(lhs, rhs));\n}\n\ntemplate <std::floating_point\
    \ T>\nT DotProduct(const Point<T>& lhs, const Point<T>& rhs) {\n    return lhs[0]*rhs[0]\
    \ + lhs[1]*rhs[1] + lhs[2]*rhs[2];\n}\n\ntemplate <std::floating_point T>\nPoint<T>\
    \ CrossProduct(const Point<T>& lhs, const Point<T>& rhs) {\n    return {\n   \
    \     lhs[1]*rhs[2]-lhs[2]*rhs[1],\n        lhs[2]*rhs[0]-lhs[0]*rhs[2],\n   \
    \     lhs[0]*rhs[1]-lhs[1]*rhs[0],\n    };\n}\n\ntemplate <std::floating_point\
    \ T>\nusing Vector = Point<T>;\n\n} // namespace geometryR3\n\n} // namespace\
    \ zawa\n#line 2 \"Src/GeometryR3/Plane.hpp\"\n\n#line 4 \"Src/GeometryR3/Plane.hpp\"\
    \n\n#line 6 \"Src/GeometryR3/Plane.hpp\"\n\nnamespace zawa {\n\nnamespace geometryR3\
    \ {\n\ntemplate <std::floating_point T>\nclass Plane {\npublic: \n\n    Plane()\
    \ = default;\n\n    Plane(const Vector<T>& p, const Vector<T>& q) : m_p{p}, m_q{q}\
    \ {}\n\n    Plane(const Point<T>& p, const Point<T>& q, const Point<T>& r) : m_p{q\
    \ - p}, m_q{r - p} {}\n\n    Vector<T> normalVector() const {\n        return\
    \ CrossProduct(m_p, m_q).normalized();\n    }\n\nprivate:\n\n    Vector<T> m_p,\
    \ m_q;\n};\n\n} // namespace geometryR3\n\n} // namespace zawa\n#line 11 \"Test/UC/3-37-M.test.cpp\"\
    \n\n#include <algorithm>\n#line 15 \"Test/UC/3-37-M.test.cpp\"\n#include <iomanip>\n\
    \nusing namespace zawa::geometryR3;\nusing point = Point<long double>;\n\nlong\
    \ double R;\npoint P, S, T;\n\nlong double CenterAngle(const point& s, const point&\
    \ t) {\n    const long double cosT = 1.0l - DistanceSquare(s, t) / (2 * R * R);\n\
    \    return acosl(std::clamp(cosT, -1.0l, 1.0l));\n}\n\nlong double ArcLength(const\
    \ point& p, const point& q) {\n    return R * CenterAngle(p, q);\n}\n\nlong double\
    \ solve() {\n    P = R * P.normalized(); \n    S = R * S.normalized(); \n    T\
    \ = R * T.normalized(); \n    const long double theta = CenterAngle(S, T);\n \
    \   auto ST = [&](long double r) -> point {\n        const point n = Plane{S,\
    \ T}.normalVector();\n        return S.rotated(n, theta * r);\n    };\n    long\
    \ double l = 0, r = 1;\n    for (int t = 0 ; t < 50 ; t++) {\n        const long\
    \ double m1 = (l + l + r) / 3, m2 = (l + r + r) / 3;\n        const long double\
    \ d1 = ArcLength(P, ST(m1)), d2 = ArcLength(P, ST(m2));\n        if (d1 <= d2)\
    \ r = m2;\n        else l = m1;\n    }\n    return ArcLength(P, ST(l));\n}\n\n\
    int main() {\n#ifdef ONLINE_JUDGE\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n\
    \    std::ios::sync_with_stdio(false);\n    int t;\n    std::cin >> t;\n    std::cout\
    \ << std::fixed << std::setprecision(7);\n    while (t--) {\n        std::cin\
    \ >> R >> P >> S >> T;\n        std::cout << solve() << '\\n';\n    }\n#else\n\
    \    std::cout << \"Hello World\\n\";\n#endif\n}\n"
  code: "// #define PROBLEM \"https://contest.ucup.ac/contest/2025/problem/10748\"\
    \n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A\"\
    \n\n/*\n * The 3rd Universal Cup. Stage 37: Wuhan M. Flight Tracker\n * https://contest.ucup.ac/submission/1067790\n\
    \ */\n\n#include \"../../Src/GeometryR3/Point.hpp\"\n#include \"../../Src/GeometryR3/Plane.hpp\"\
    \n\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\
    \nusing namespace zawa::geometryR3;\nusing point = Point<long double>;\n\nlong\
    \ double R;\npoint P, S, T;\n\nlong double CenterAngle(const point& s, const point&\
    \ t) {\n    const long double cosT = 1.0l - DistanceSquare(s, t) / (2 * R * R);\n\
    \    return acosl(std::clamp(cosT, -1.0l, 1.0l));\n}\n\nlong double ArcLength(const\
    \ point& p, const point& q) {\n    return R * CenterAngle(p, q);\n}\n\nlong double\
    \ solve() {\n    P = R * P.normalized(); \n    S = R * S.normalized(); \n    T\
    \ = R * T.normalized(); \n    const long double theta = CenterAngle(S, T);\n \
    \   auto ST = [&](long double r) -> point {\n        const point n = Plane{S,\
    \ T}.normalVector();\n        return S.rotated(n, theta * r);\n    };\n    long\
    \ double l = 0, r = 1;\n    for (int t = 0 ; t < 50 ; t++) {\n        const long\
    \ double m1 = (l + l + r) / 3, m2 = (l + r + r) / 3;\n        const long double\
    \ d1 = ArcLength(P, ST(m1)), d2 = ArcLength(P, ST(m2));\n        if (d1 <= d2)\
    \ r = m2;\n        else l = m1;\n    }\n    return ArcLength(P, ST(l));\n}\n\n\
    int main() {\n#ifdef ONLINE_JUDGE\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n\
    \    std::ios::sync_with_stdio(false);\n    int t;\n    std::cin >> t;\n    std::cout\
    \ << std::fixed << std::setprecision(7);\n    while (t--) {\n        std::cin\
    \ >> R >> P >> S >> T;\n        std::cout << solve() << '\\n';\n    }\n#else\n\
    \    std::cout << \"Hello World\\n\";\n#endif\n}\n"
  dependsOn:
  - Src/GeometryR3/Point.hpp
  - Src/Template/TypeAlias.hpp
  - Src/GeometryR3/Plane.hpp
  isVerificationFile: true
  path: Test/UC/3-37-M.test.cpp
  requiredBy: []
  timestamp: '2025-05-21 20:07:18+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: Test/UC/3-37-M.test.cpp
layout: document
redirect_from:
- /verify/Test/UC/3-37-M.test.cpp
- /verify/Test/UC/3-37-M.test.cpp.html
title: Test/UC/3-37-M.test.cpp
---
