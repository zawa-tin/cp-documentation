---
title: ABC193-F Zebraness
documentation_of: //Test/AtCoder/abc193_f.test.cpp
---

燃やす埋める。いくつかのポイントを残しておく

## しまうま度(得)の最大化 -> しまうまじゃない度(損)の最小化 と言い換える

理想のしまうまから最小カット容量(損としてあり得る最小)を引いてあげる。

理想のしまうまは明らかに市松模様に塗られた時である。(その時のしまうま度は $2\times N\times (N - 1)$ の様だ)

## ?で無いマスに対しても白に変更するか黒に変更するかを考慮する。

?であるマスに対しての割当では無く、全てのマスに対して白か黒かを割り当てる問題と考えた方が後々の思考コストが下がるようだ。

この場合、「白マスを黒マスに割り当てる」や「黒マスを白マスに割り当てる」は「やってはいけない」割当であり、そのような割当には $\infity$ の損とする
- 禁止を無限の損と言い換える良く見るやつ

## マスの変更自体に損は無い

「マス $(i, j)$ とマス $(i + 1, j)$ が同じ色の時、 1損する」みたいな2つの特定の割当によって発生するコストをsource -> マスやマス -> sinkの容量に記述してはいけない(頭が壊れる)

## グリッドグラフは市松で考える

ネットワークの構築を試みる。例として右左に隣り合う?のマスに対してどのように辺が張られるかを考える。
- source -(0)-> 左マス (左マスを白にすると0の損)
- 左マス -(0)-> sink (左マスを黒にすると0の損)
- source -(0)-> 右マス (右マスを白にすると0の損)
- 右マス -(0)-> sink (右マスを黒にすると0の損)

ここまでは良いが、「左のマスと右のマスが同じ色の時に1の損」が上手く記述できない。
- 例えば左マス -(1)-> 右マスとしてもこの辺を切らせることはできない。両方白or両方黒のカットがコスト0でできている

ここで、グリッドグラフの4近傍は二部グラフであることを思い出すと、市松の片方のsourceとsinkを反転させてあげれば良い
- source -(0)-> 左マス (左マスを白にすると0の損)
- 左マス -(0)-> sink (左マスを黒にすると0の損)
- source -(0)-> 右マス (右マスを**黒**にすると0の損)
- 右マス -(0)-> sink (右マスを**白**にすると0の損)
- 右マス -(1) -> 左マス (左マスを白、右マスを白にすると1の損)
- 左マス -(1)-> 右マス (左マスを黒、右マスを黒にすると1の損)
